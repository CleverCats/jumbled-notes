#include<iostream>
using namespace std;
class Base1{
public:
	int b1_a=10;
	Base1()
	{ 
		b1_a = 10;
	};
};
//可以理解为每个实现虚继承的类都有自己的虚基表,记录关于本类this指针与vbptr与虚继承下来的成员变量的偏移量
class Derive :virtual public Base1{     
//虚继承后,子类就会被插入一个虚基类指针vbptr(隐藏的成员变量),指向虚基表vbtable(在编译阶段就生成)的首地址,vbptr放在内存头部
	/*-----------------------------------------------------------------------------------------------------------------------------------*/
//虚基表最少为8个字节,1-4字节记录vbptr与this的偏移量,5-8字节记录vbptr与被虚继承的基类成员变量(在内存尾部)相对于this的指针偏移量[Ps::以vbptr为0点,上方为负偏移,下方为正偏移]
//每多虚继承一个父类.那么虚基表字节便+4(为静态全局区,不占用对象内存),该4字节记录this与此新的虚继承父类的成员变量(放在内存尾部)相对于vbptr指针偏移量
	/*-----------------------------------------------------------------------------------------------------------------------------------*/
//作用:在反汇编可以看出,对成员变量的存取都是通过 this+偏移量 寻址的,但虚继承的基类的成员变量则需要通过vbptr在vbtable中寻找需要偏移量然后在偏移(开发者这样设计一定有他的道理)
//ps:继承,虚基表中虚基类的成员放在内存布局的最下方,导致偏移量不是固定的，虚基表的数据会被拷贝下来并更新为适合当前vbttr相对于this指针与this相对于虚基类成员变量的偏移量
//所以访问虚继承下来的成员变量会比普通继承下来的慢一些,因为需要通过vbptr在vbtable寻找获取偏移量,而其他普通成员在编译阶段就确定了偏移量,在访问时直接this偏移.
//也就是只有访问虚基类的成员时才会使用vbptr与vbtable
//如果是普通继承+虚继承的混合继承,那么普通继承成员会放在对象内存最上方,而后才是虚继承的对象成员,当然,因为虚继承在后,所以vbptr就在普通继承的的成员下面(也即虚继承的成员上方)
//注意:普通继承和虚继承还是按继承顺序继承,只不过这里虚继承的成员会放在普通继承下方
//补充:一个基类被两个子类同时虚继承那么这个基类就是虚基类,构造子类时会由子类优先单独初始化构造,且继承成员防止内存尾部
public:
	int d1_a=20;
	Derive()
	{
		int i = 0;
	}
};
class Derive2:virtual public Base1{
//同上被插入一个虚基类指针vbptr(隐藏的成员变量),指向虚基表vbtabl(该虚基表是拷贝过来然后更新,里面存放8个字节的Derive2类关于虚继承的成员的相关偏移量),vbptr放在内存头部
public:
	int d2_a = 30;
	Derive2()
	{
		int i = 0;
	}
};
class GDerive :public Derive,public Derive2{
//将直接父类的成员变量顺序(vbptr同样继承)继承下来.但将父类的成员防止内存的尾部
//这里因为继承原因存在两个vbptr
//一般只会用到第一个vbptr,父类指针接收子类成员发生this指着偏移到子类内存布局中继承的父类的this位置,使用改this访问改父类虚继承的成员变量是才会用到第二个vbptr

//不同厂商实现编译器的虚基类方法不同.这里是微软的版本
public:
	int Gd_a = 40;
	GDerive()
	{
		int i = 0;
	}
};

int main()
{
	GDerive Gdiv;
	cout << sizeof(Base1) << endl;
	cout << sizeof(Derive) << endl;
	cout << sizeof(GDerive) << endl;
	Derive div;
	system("pause");
	return 0;
}