#include<iostream>  

//总结:继承后如果与子类没有同名成员,那么子类与父类共享数据,数据地址相同,无论加不加作用域都是访问的一个地址,因此也可以改变共享数据
//如果有同名函数,那么同名的成员数据不共享,地址不同，但因为继承,子类可以通过作用域调用父类的同名成员,改变父类不会改变子类,改变子类不会改变父类
                                                                     //（或者使用using在子类中 声明）

                                        // **********非虚基类继承机制****************

//如果存在多继承(不存在虚继承), A(爷爷,拥有成员变量 a) B（爷爷的派生类） C（独立类）      D:public C，public B
//此时 D obj;   obj的构造顺序  1.C  2.A  3.B  ，C独立初始化不间接初始化其他类； 准备初始化构造B时识别有B有父类A ，因此先跳转初始化构造A，在回到B构		造,所以先A后B
//且此时 C 是一条构造线路   A-B 是另一条构造线路 ,所以A-B继承的数据共享 与 C的数据 无关;A-B共享的数据共享给D，C的数据共享给D
//结果: D-B-A共享一些继承数据,D-C共享继承数据  但 B-A-C之间的数据无关


                                        //************虚基类继承机制****************

//如果存在虚继承   A(爷爷,拥有成员变量 a) B:virtual public:A  C: virtual public:A    D:public C，public B
//A的派生类B，C采用 virtual的方式继承 A类,A类就被称为虚基类, 这样可以保证,D在继承C ,B类的时候,不会2次继承 A的a,导致数据的二义性
//此时D obj;  obj的构造顺序  1.A 2.C 3.B ;最底层派生类构造时发现有虚基类(A),就立即先跳转到虚基类初始化构造,然后在构造C，此时,C也存在初始化虚基类的	  操作但是,虚基类只允许最底层派生类初始化,所以,C初始化时不会再次跳转到虚基类构造,会忽略该请求,继续构造C, C构造完后同理构造B 
//  B作为最底层的派生类,现在由它来初始化构造虚基类A,即初始化A中的a,保证A与D直接仅的a仅一个不会存在二义性
// 结果 D-A-B-C共享继承数据，因为顶层基类是虚基类,虚基类是由底层派生类D初始化,B,C只负责在D初始化A后继承基类A，不会在次初始化基类A,所以4者数据共享,
   且不会出现二义性

//不采用虚继承的结果: D中会两次继承 A继承两份同名数据,构造数据的二义性

using namespace std;
class A
{
public:
	int x = 10;
	int y = 20;
	void print(int)
	{
		cout << "call A print_int_int" << endl;
	}
};
class  B :public A
{
public:
	int y = 20;
	void print(int)
	{
		cout << A::x << endl;
		cout << "call B print_int" << endl;
	}

};
int main()
{
	B b;

	//与如下的成员变量调用同理
	b.print(10);
	b.A::print(10);

	//输出结果30,30 且地址相同
	//因为x是父类独有有,继承后子类与父类共享,所以地址相同,数据相同
	b.x = 20;   //父类 x
	b.A::x = 30;  //父类 x
	cout << "b.x="<<b.x <<"\tadress=  "<<&b.x << endl;
	cout << "b.A::x=" << b.A::x << "\tadress=  " << &b.A::x << endl;


//输出结果为30,,40且地址不同
//因为父类与子类具有同名的成员,此时父类与子类的同名成员在各自的作用域,并不是共享数据,但因为继承关系,子类可以调用父类的数据,此时需要加作用域
	b.y = 30;   //子类 y
	b.A::y = 40;  //父类 y
	cout << "b.y=" << b.y << "\tadress=  " << &b.y<< endl;
	cout << "b.A::y=" << b.A::y << "\tadress=  " << &b.A::y << endl;

	//输出结果为30,因为x是父类独有有,继承后子类与父类共享
	//所以b.x与b.A::x地址相同 
	/*	b.x = 20;
		b.A::x = 30;     因此这两句都会改变共享数据的值*/
	b.print(10);
	system("pause");
	return 0;
}