#include<iostream>
using namespace std;

//一 .结构体
struct A
{
				//1.结构体变量可以在结构体内全部初始化

	int a/*=5*/;

	//采用默认初始化 char b='A'; 但是在结构体内初始化后在外就不能使用  A m_a2={ 参数1 , 参数2 , 参数三  }的方式初始化了

	char b/*='A'*/;
	char c[20];
}m_a1;			//2. 结构体也可以在尾部生成结构体对象,相当于执行了 A m_a1;类也同样适用


//二 .共用体(有名) 又称 联合,如果无名,则必须在结构体尾部实例化一个对象,不可在其他地方实例化
union B
{
				//1. 共用体可以在共有体初始化,但区别与结构体,只能初始化第一个成员,因为地址共存,会互相覆盖,编译器禁止了该操作

	int a;
	char b;
	char c[20];
}/*m_b1*/;         //2. 共用体对象也可以选择在尾部生成共用体对象,相当于执行了 B m_a1;

int main()
{
					//结构体初始化:不可以有默认值的情况下初始,但可以一次初始化多个成员

	A m_a2 = { 2020,'A', "hellow world" };  //结构体对象实例化:与class实例化的方法相同

		//3.结构体大小:结构体大小>=(一般等于)成员变量的字节大小总和,每个成员函数有自己的内存地址
	cout << "sizeof(A)= " << sizeof(A) << endl;

		//3.共用体可以同结构体一样 实例化对象(成员没有默认值下),但不可使用{ }同时初始化多个成员，只能初始化一个成员
	//B m_b2 = { 2019, 'B', "Hi world" };错误
		
		B m_b2;
		cout << "-------------------------------------------------------" << endl;
		m_b2.a = 5;
		m_b2.b = 'A';   //覆盖内存

		//地址相同
		cout << "adress 1= " << &m_b2.a << endl;
		cout << "adress 2= " << &m_b2.b << endl;
		cout << "adress 3= " << &m_b2.c << endl;
		//4.共用体的成员地址相同,共用一块起始内存,内存的大小为占内存最大的成员内存大小，因为内存共有,所以每一刻只允许一个成员有值,否则后来者会覆盖前者
	cout << "sizeof(B)= " << sizeof(B) << endl;
		

		//总结:共用体 与 结构体 最大的区分 ,共用体成员共用同一片内存,每一刻只允许一个成员有值,后者赋值前者,内存就会被后者覆盖导致前者调用无效
				//结构体则分配成员各自的内存,不会发生覆盖




		//注意:共用体变量不能作为函数参数,也不可让函数带共用体变量,而结构体可以
	system("PAUSE");
	return 0;
}