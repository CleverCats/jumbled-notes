理解同步与异步I/O不要和阻塞非阻塞I/O混淆:

异步I/O:调用一个异步I/O函数,需要给这个函数指定一个接收缓冲区【来接收客户端的数据】,还要指定一个回调函数【用来处理数据】
        该函数不会做任何卡顿停留,而是会直接返回往下执行,这个判断数据是否到来由操作系统内核来判断,如果系统检测到数据到来了
        系统就会将数据从内核缓冲区复制到你所提供的缓存区,然后调用你提供的回调函数

异步I/O与非阻塞I/O区别:
非阻塞I/O:  需要不断调用I/O函数来检测数据是否到来,如果数据来了就卡在这里把数据从内核缓冲区复制到用户缓冲区,然后这个函数返回成功标识,
            如果没来就返回【EWOULDBLOCK】表示数据还没来,可以根据返回值判断再去其他事情,同时继续回调用数据判断函数,直到数据来了根据返回值正确处理

异步I/O:    不需要不断调用I/O函数来检查数据是否来了,而是只调用一次异步I/O函数,数据的到来由系统判断,数据到来后就调用指定的回调函数
	   【异步I/O进行数据拷贝是在内核进行的,没有任何阻塞,这点区别区于其他任何I/O模式】

补充:其他非异步I/O实际上在数据拷贝都是有阻塞行为,只有异步I/O没有阻塞行为,
     所以有的资料书甚至将【其它I/O统称同步I/O】,也就是只分为【同步I/O】与【异步I/O】


同步I/O与阻塞I/O的区别
同步I/O:    调用select/poll等函数,select函数用来判断是否有数据,如果没有卡住那里,如果有select函数返回走下来,使用recvfrom读取数据
            当然这个读取数据的过程也是内核缓存区到用户缓存区的拷贝会卡在这里一会
//这里目前看来似乎同步I/O和阻塞I/O相同,并且同步I/O还调用了2个函数,一个select用于判断,一个recvfrom用于读取
  而阻塞I/O只需要一个函数就完成了判断和读取,好像更麻烦,其实同步I/O有它独特的优势技术【I/O复用】

*************************************************************
区别优势:select判断的其实是已完成连接队列的多个TCP连接状态,只要有任意一个有数据发送,那么就select马上返回,然后调用recvfrom处理数据
在阻塞I/O中,判断和读取为同一个函数时,只能顺序判断指定TCP连接的数据传输状态,上一个客户端的数据没有检测到,就不能处理下一个客户端的数据
**************************************************************

补充:这种【拥有】有多个socket【TCP连接】看作一捆,
     可以用select这种同步I/O函数等待任意一个socket发送过来数据的【能力】,叫做【I/O复用】,也可叫英文I/O multiplexing【I/O多路复用】
     select判断后在调用recvfrom这种函数来处理数据,这种比阻塞I/O更具有优势